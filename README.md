#  üéÆ MinMax - An√°lise Assint√≥tica

<div align="center">
   <img align="center" height="20px" width="80px" src="https://img.shields.io/badge/Ubuntu-orange?logo=ubuntu">
   <img align="center" height="20px" width="80px" src="https://img.shields.io/badge/VS%20Code-blue?logo=visual%20studio%20code"/>
   <img align="center" height="20px" width="80px" src="https://img.shields.io/badge/MakeFile-green?logo=make">
   <img align="center" height="20px" width="60px" src="https://img.shields.io/badge/C%2B%2B-darkblue?logo=c%2B%2B"/>
</div>

<details>
  <summary>üìå T√≥picos</summary>
    <ol>
        <li><a href="#-introdu√ß√£o">Introdu√ß√£o</a></li>
        <li><a href="#-an√°lise-assint√≥tica">An√°lise Assint√≥tica</a></li>
        <li><a href="#-implementa√ß√£o">Implementa√ß√£o</a></li>
        <li><a href="#-estrutura-de-diretorios">Estrutura de Diret√≥rios</a></li>
        <li><a href="#-como-usar">Como Usar</a></li>
        <li><a href="#-exemplos">Exemplos</a></li>
        <li><a href="#-resultados-das-an√°lises">Resultados Das An√°lises</a></li>
        <li><a href="#-conclus√£o">Conclus√£o</a></li>
        <li><a href="#-ambiente-de-compila√ß√£o">Ambiente de Compila√ß√£o</a></li>
        <li><a href="#-makefile">MakeFile</a></li>
        <li><a href="#-contato">Contato</a></li>
        <li><a href="#-refer√™ncias">Refer√™ncias</a></li>
    </ol>
</details>

## üëã Introdu√ß√£o 

A an√°lise assint√≥tica √© uma t√©cnica essencial em ci√™ncia da computa√ß√£o que nos permite entender o comportamento de algoritmos √† medida que o tamanho do problema aumenta. Esta an√°lise fornece insights valiosos sobre a efici√™ncia e o desempenho dos algoritmos em diferentes cen√°rios, o que √© crucial para a otimiza√ß√£o e a compara√ß√£o entre algoritmos. Neste contexto, os algoritmos de MinMax desempenham um papel proeminente.

Os algoritmos de MinMax s√£o amplamente utilizados em uma variedade de contextos computacionais, sendo especialmente proeminentes em jogos de estrat√©gia de dois jogadores, como xadrez e jogo da velha. Sua ess√™ncia reside em determinar a melhor jogada poss√≠vel para um jogador, considerando todas as poss√≠veis a√ß√µes do oponente. Al√©m de sua aplica√ß√£o pr√°tica, uma compreens√£o profunda da an√°lise assint√≥tica desses algoritmos √© fundamental.

Neste reposit√≥rio, exploramos tanto a an√°lise assint√≥tica dos algoritmos de MinMax quanto sua import√¢ncia na computa√ß√£o moderna. Ao faz√™-lo, esperamos proporcionar uma compreens√£o abrangente desses algoritmos fundamentais e seu papel na otimiza√ß√£o de algoritmos e na compara√ß√£o entre eles.

## üìä An√°lise Assint√≥tica

Ao compreender a an√°lise assint√≥tica, podemos entender o desempenho e a efici√™ncia desses algoritmos fundamentais. Por meio da an√°lise cuidadosa do tempo de execu√ß√£o e uso de mem√≥ria, podemos compreender como esses algoritmos se comportam √† medida que o tamanho do problema cresce. Esta an√°lise n√£o apenas nos permite avaliar a efici√™ncia dos algoritmos em diferentes cen√°rios, mas tamb√©m nos ajuda a comparar e selecionar o algoritmo mais adequado para uma determinada tarefa. 

### üë®‚Äçüíª An√°lise de Algoritmos
A an√°lise de algoritmos se concentra em entender, estudar e avaliar a corre√ß√£o e o desempenho dos algoritmos. Um algoritmo √© uma sequ√™ncia de passos bem definidos que resolve um problema espec√≠fico. A an√°lise de algoritmos busca responder perguntas como:

1. **Efici√™ncia:** Qu√£o r√°pido um algoritmo resolve um problema? Quanta mem√≥ria ele consome?
2. **Escalabilidade:** Como o desempenho do algoritmo √© afetado quando a entrada de dados cresce?
3. **Complexidade:** Qual √© a complexidade do algoritmo? Isso significa qu√£o dif√≠cil √© compreend√™-lo e implement√°-lo.

A an√°lise de algoritmos geralmente se concentra em duas medidas principais:

1. **Tempo de execu√ß√£o:** Isso envolve determinar quanto tempo um algoritmo leva para concluir, muitas vezes referido como "tempo de execu√ß√£o" ou "complexidade de tempo". Pode ser medido em termos de tempo real (segundos, milissegundos, etc.) ou em termos de opera√ß√µes fundamentais (como compara√ß√µes ou movimentos de dados).

2. **Espa√ßo de armazenamento:** Isso refere-se √† quantidade de mem√≥ria que um algoritmo consome durante sua execu√ß√£o, muitas vezes chamado de "complexidade de espa√ßo". Isso pode incluir o espa√ßo necess√°rio para armazenar vari√°veis, estruturas de dados tempor√°rias e quaisquer outras aloca√ß√µes de mem√≥ria feitas pelo algoritmo.

Existem v√°rias t√©cnicas para analisar algoritmos:

1. **An√°lise te√≥rica:** Isso envolve an√°lise matem√°tica e c√°lculos para determinar o tempo de execu√ß√£o e a complexidade de espa√ßo do algoritmo. Isso geralmente √© feito usando nota√ß√µes como a nota√ß√£o Big O, Theta e Omega.

2. **Experimenta√ß√£o pr√°tica:** Isso envolve implementar o algoritmo em um ambiente de programa√ß√£o e medir seu desempenho com entradas de dados de diferentes tamanhos. Embora menos preciso do que a an√°lise te√≥rica, pode ser √∫til para validar as previs√µes te√≥ricas e fornecer informa√ß√µes sobre o desempenho do mundo real.

3. **Compara√ß√£o emp√≠rica:** Isso envolve comparar o desempenho de diferentes algoritmos para o mesmo problema e determinar qual √© mais eficiente em termos de tempo de execu√ß√£o e uso de mem√≥ria.

### üñãÔ∏è Nota√ß√£o Assint√≥tica
A nota√ß√£o assint√≥tica √© uma ferramenta importante na an√°lise de algoritmos e desempenho de programas. Ela nos permite descrever o comportamento de uma fun√ß√£o √† medida que sua entrada tende ao infinito. Isso √© √∫til para entender como o tempo de execu√ß√£o de um algoritmo ou o uso de recursos (como mem√≥ria) cresce conforme o tamanho do problema aumenta.

Existem tr√™s nota√ß√µes assint√≥ticas comuns:

#### üìç Nota√ß√£o O (Big O):
Isso descreve o limite superior do comportamento de uma fun√ß√£o. Em termos simples, representa o pior cen√°rio poss√≠vel. Se uma fun√ß√£o f(n) √© O(g(n)), isso significa que, para valores suficientemente grandes de n, f(n) nunca crescer√° mais rapidamente do que uma constante m√∫ltipla de g(n).

<p align="center">
    <b>0‚â§f(n)‚â§c‚àóg(n),‚àÄn‚â•n0</b>

<figure align="center">
  <img src="./images/imgs_readme/notacaoO.jpeg" alt="Gr√°fico Exemplo" width="500" >
  <figcaption>Fonte: Autor</figcaption>
</figure>
</p>

#### üìç Nota√ß√£o Œ© (Big Omega)
Essa nota√ß√£o descreve o limite inferior do comportamento de uma fun√ß√£o. Representa o melhor cen√°rio poss√≠vel. Se f(n) √© Œ©(g(n)), isso significa que, para valores suficientemente grandes de n, f(n) nunca crescer√° mais lentamente do que uma constante m√∫ltipla de g(n).

<p align="center">
    <b>0‚â§c‚àóg(n)‚â§f(n),‚àÄn‚â•n0</b>

<figure align="center">
  <img src="./images/imgs_readme/notacaoOmega.jpeg" alt="Gr√°fico Exemplo" width="500" >
  <figcaption>Fonte: Autor</figcaption>
</figure>
</p>

#### üìç Nota√ß√£o Œò (Big Theta)
Esta nota√ß√£o descreve o comportamento exato de uma fun√ß√£o. Se f(n) √© Œò(g(n)), isso significa que f(n) cresce na mesma taxa que g(n) √† medida que n tende ao infinito. Em outras palavras, f(n) √© limitada superior e inferiormente por uma constante m√∫ltipla de g(n).

<p align="center">
    <b>0‚â§c1‚àóg(n)‚â§f(n)‚â§c2‚àóg(n),‚àÄn‚â•n0</b>

<figure align="center">
  <img src="./images/imgs_readme/notacaoTheta.jpeg" alt="Gr√°fico Exemplo" width="500" >
  <figcaption>Fonte: Autor</figcaption>
</figure>
</p>


### üöÄ Aplica√ß√£o da An√°lise Assint√≥tica

Essas nota√ß√µes s√£o √∫teis porque nos permitem expressar o desempenho de um algoritmo de forma concisa e independente de fatores espec√≠ficos, como a velocidade do processador ou a quantidade exata de mem√≥ria dispon√≠vel. Elas nos ajudam a entender o comportamento geral de um algoritmo √† medida que lidamos com entradas maiores, para projetar algoritmos eficientes e escal√°veis.

A an√°lise assint√≥tica desempenha um papel crucial em uma variedade de contextos pr√°ticos, desde a otimiza√ß√£o de algoritmos at√© o projeto de sistemas computacionais. No contexto deste trabalho, exploramos a aplica√ß√£o da an√°lise assint√≥tica para compreender e comparar o desempenho de diferentes algoritmos de MinMax. 

Aqui, foi desenvolvido em C++ um programa que faz coleta dados de tempo de execu√ß√£o de tr√™s algoritmos diferentes para encontrar o maior e o menor valor de um vetor, de tamanhos diferentes e organizados de formas diferentes. Vamos primeiro enteder como foi implementado para depois discutimos os resultados. 

## üìù Implementa√ß√£o

Este projeto consiste em um conjunto de fun√ß√µes em C++ que implementam tr√™s algoritmos diferentes para encontrar o valor m√°ximo e m√≠nimo em um vetor de inteiros. Os algoritmos s√£o:

- **MaxMin1:** Este algoritmo percorre o vetor uma vez para encontrar o m√°ximo e o m√≠nimo.
- **MaxMin2:** Similar ao MaxMin1, mas utiliza uma estrutura de controle diferente para verificar o m√°ximo e o m√≠nimo.
- **MaxMin3:** Este algoritmo utiliza uma abordagem em an√©is para encontrar o m√°ximo e o m√≠nimo.

Al√©m da implementa√ß√£o dos algoritmos, o programa realiza uma an√°lise de desempenho abrangente. Cada algoritmo √© executado 10 vezes para cada combina√ß√£o de tamanho de vetor (1000, 10000, 100000, 500000) e configura√ß√£o de ordena√ß√£o (aleat√≥rio, crescente, decrescente). Os tempos de execu√ß√£o s√£o registrados e os resultados s√£o armazenados em um arquivo CSV para posterior an√°lise.

Posteriormente, s√£o gerados gr√°ficos a partir dos dados do arquivo CSV, permitindo uma visualiza√ß√£o clara das diferen√ßas de desempenho entre os algoritmos para diferentes cen√°rios de entrada.

### üîç Algoritmos MinMax
Os algoritmos `MaxMin1`, `MaxMin2` e `MaxMin3` s√£o implementados para resolver o problema de encontrar o m√°ximo e o m√≠nimo em um vetor de forma eficiente.

1. **MaxMin1:** O algoritmo `MaxMin1` percorre o vetor uma √∫nica vez para encontrar o valor m√°ximo e m√≠nimo. Ele inicializa as vari√°veis Max e Min com o valor do segundo elemento do vetor e, em seguida, percorre o restante do vetor comparando cada elemento com Max e Min e atualizando-os conforme necess√°rio.
``` cpp
    void MaxMin2(int A[], int n, int &Max, int &Min) {
        Max = A[0];
        Min = A[0];

        for (int i = 1; i < n; i++) {
            if (A[i] > Max) {
                Max = A[i];
            } else if (A[i] < Min) {
                Min = A[i];
            }    <figure align="center">
    <img src="./images/imgs_readme/graficoExemploMedias.png" alt="Gr√°fico Exemplo" width="500" >
    <figcaption>Fonte: Autor</figcaption>
    </figure>
        }
    }   
```

2. **MaxMin2:** O algoritmo `MaxMin2` √© semelhante ao `MaxMin1`, mas utiliza uma estrutura de controle diferente. Ele tamb√©m percorre o vetor uma √∫nica vez e compara cada elemento com Max e Min, mas utiliza uma estrutura if-else para verificar se o elemento √© maior que Max ou menor que Min.
``` cpp
    void MaxMin2(int A[], int n, int &Max, int &Min) {
        Max = A[1];
        Min = A[1];
        for (int i = 1; i < n; i++) {
            if (A[i] > Max) {
                Max = A[i];
            } else if (A[i] < Min) {
                Min = A[i];
            }
        }
    }
```

3. **MaxMin:** O algoritmo MaxMin3 utiliza uma abordagem em an√©is para encontrar o valor m√°ximo e m√≠nimo. Ele √© projetado para lidar com vetores de tamanho √≠mpar e par de forma eficiente, garantindo que todos os elementos do vetor sejam comparados entre si.
``` cpp
    void MaxMin3(int A[], int n, int &Max, int &Min) {
        int i, FimDoAnel = 0;

        if (n % 2 > 0) {
            A[n] = A[n - 1];
            FimDoAnel = n;
        } else {
            FimDoAnel = n - 1;
        }

        if (A[0] > A[1]) {
            Max = A[0];
            Min = A[1];
        } else {
            Max = A[1];
            Min = A[0];
        }

        i = 2;
        while (i < FimDoAnel) {
            if (A[i] > A[i + 1]) {
                if (A[i] > Max) {
                    Max = A[i];
                }
                if (A[i + 1] < Min) {
                    Min = A[i + 1];
                }
            } else {
                if (A[i + 1] > Max) {
                    Max = A[i + 1];
                }
                if (A[i] < Min) {
                    Min = A[i];
                }
            }

            i += 2;
        }
    }
```

### ‚è±Ô∏è Medi√ß√£o e Armazenamento do Tempo de Execu√ß√£o
Para avaliar o desempenho dos algoritmos de busca do valor m√°ximo e m√≠nimo em um vetor, foram realizadas medi√ß√µes precisas do tempo de execu√ß√£o. Essas medi√ß√µes foram feitas utilizando a biblioteca `<chrono>` do C++, que oferece uma maneira confi√°vel de medir tempos em alta resolu√ß√£o. O tempo de execu√ß√£o de cada algoritmo foi medido em diferentes cen√°rios, incluindo diferentes tamanhos de vetor e diferentes configura√ß√µes de ordena√ß√£o. Os resultados foram registrados em um arquivo CSV, fornecendo uma base de dados para an√°lise detalhada do desempenho de cada algoritmo em diversas condi√ß√µes. A fun√ß√£o `execucao` que est√° no arquivo `minMax.cpp` √© respons√°vel por realizar a execu√ß√£o dos algoritmos, medir o tempo de execu√ß√£o e armazenar os resultados.

1. **Defini√ß√£o de Vari√°veis e Loops Externos**
    - Nesta parte, s√£o definidas as vari√°veis necess√°rias para controlar o tamanho do vetor (`n`), o tempo de execu√ß√£o m√©dio (`tempoExecMedio`) e as strings para armazenar informa√ß√µes sobre a ordem do vetor e o algoritmo utilizado.

    - Em seguida, √© iniciado um loop externo que percorre quatro diferentes tamanhos de vetores (1000, 10000, 100000, 500000). O valor de `n` √© atualizado em cada itera√ß√£o do loop de acordo com o tamanho do vetor atual.

    ```cpp
        void execucao(std::string arquivoSaida) {
            int n;
            int Max, Min;
            double tempoExecMedio;
            std::string ordem;
            std::string algoritmo; 
            std::ofstream outputFile(arquivoSaida);

            if(!outputFile.is_open()) {
                std::cerr << "Erro ao abrir o arquivo: " << arquivoSaida << std::endl;
                return;
            }

            std::cout << "Executando algoritmos..." << std::endl;
            for (int i = 0; i < 4; i++) {
                if(i == 0) {
                    n = 1000;
                } else if(i == 1) {
                    n = 10000;
                } else if(i == 2) {
                    n = 100000;
                } else if(i == 3) {
                    n = 500000;
                }
    ```

2. **Aloca√ß√£o e Ordena√ß√£o do Vetor**
    - Dentro do loop externo, um novo vetor `A` √© alocado dinamicamente com o tamanho determinado por `n`.

    - Em seguida, um loop interno percorre tr√™s diferentes tipos de organiza√ß√£o do vetor: `Aleat√≥rio`, `Crescente` e `Decrescente`.

    - Inicialmente o vetor √© preenchido com valores aleat√≥rios, depois, dependendo do tipo de organiza√ß√£o (`j`), ele √© ordenado utilizando a fun√ß√£o `std::sort`, de forma crescente e depois decrescente.

    ```cpp
            int* A = gerarVetor(n);
            for (int j = 0; j < 3; j++) { 
                if(j == 1) {
                    std::sort(A, A + n);
                } else if(j == 2) {
                    std::sort(A, A + n, std::greater<int>());
                }
    ```

3. **Execu√ß√£o dos Algoritmos e Medi√ß√£o do Tempo de Execu√ß√£o**
    - Dentro do loop interno, cada um dos tr√™s algoritmos (`MaxMin1`, `MaxMin2` e `MaxMin3`) √© executado 10 vezes para cada tipo de organiza√ß√£o do vetor.

    - O tempo de execu√ß√£o de cada execu√ß√£o √© medido utilizando a biblioteca `<chrono>`.

    - Ap√≥s a execu√ß√£o dos algoritmos, os resultados s√£o ent√£o armazenados em um arquivo CSV (`resultados.csv`) junto com informa√ß√µes sobre o tamanho do vetor, a organiza√ß√£o do vetor e o n√∫mero do algoritmo.
   
    - Finalmente, a mem√≥ria alocada para o vetor `A` √© liberada antes de encerrar a fun√ß√£o.

    ```cpp
                    for (int k = 0; k < 3; k++) { 
                    std::cout << "\n--------------------" << std::endl;
                    std::cout << "Tamanho do vetor: " << n << std::endl;
                    std::cout << "Ordem: " << ordem << std::endl;
                    std::cout << "Algoritmo: MinMax" << k+1 << std::endl << std::endl;
                    for (int l = 0; l < 10; l++) {
                        auto inicio = std::chrono::high_resolution_clock::now();
                        if(k == 0) {
                            MaxMin1(A, n, Max, Min);
                        } else if(k == 1) {
                            MaxMin2(A, n, Max, Min);
                        } else if(k == 2) {
                            MaxMin3(A, n, Max, Min);
                        }              
                        auto fim = std::chrono::high_resolution_clock::now();
                        std::chrono::duration<double, std::milli> tempoExec = (fim - inicio);

                        tempoExecMedio += tempoExec.count();
                        if (j == 0) {
                            ordem = "Aleatorio";
                        } else if (j == 1) {
                            ordem = "Crescente";
                        } else if (j == 2) {
                            ordem = "Decrescente";
                        }

                    outputFile << n << "," << ordem << "," << k+1 << "," << tempoExec.count() << "\n";
                    std::cout << "Execu√ß√£o " << l+1 << std::endl;
                    std::cout << "Tempo de execu√ß√£o: " << tempoExec.count() << " ms" << std::endl;
                    std::cout << "Max: " << Max << std::endl;
                    std::cout << "Min: " << Min << std::endl;
                    std::cout << std::endl;
                    }
                }
            }
            delete[] A;
        }

        
        std::cout << "Execu√ß√£o finalizada." << std::endl;
        std::cout << "\n-------------------------------" << std::endl;
        std::cout << "Resultados salvos em " << arquivoSaida << std::endl;
    }
    ```

4. **C√°lculo das m√©dias e reorganiza√ß√£o do arquivo**
    - Foi criada uma fun√ß√£o `resultadosMedias` para calcular a m√©dia, pegando os dados do arquivo `resultados.csv` e ap√≥s o c√°lculo, a m√©dia √© guardado no arquivo `resultadosMedias.csv`.

    ```cpp
    void resultadosMedias (std::string arquivoEntrada, std::string arquivoSaida) {
        std::ifstream inputFile(arquivoEntrada);
        std::ofstream outputFile(arquivoSaida);

        if (!inputFile || !outputFile) {
            std::cerr << "Erro ao abrir os arquivos." << std::endl;
            return;
        }

        std::string line;
        int count = 0;
        double sum = 0.0;
        std::string currentKey;
        while (std::getline(inputFile, line)) {
            std::stringstream ss(line);
            std::string token;
            std::string key;

            std::getline(ss, token, ',');
            key += token + ",";
            std::getline(ss, token, ',');
            key += token + ",";
            std::getline(ss, token, ',');
            key += token;

            if (std::getline(ss, token, ',')) {
                try {
                    double value = std::stod(token);
                    sum += value;
                    count++;
                    currentKey = key;  
                } catch (const std::invalid_argument& e) {
                    std::cerr << "Erro ao converter '" << token << "' para double." << std::endl;
                    return;
                }
            }

            if (count == 10 && currentKey == key) {
                double average = sum / 10.0;
                outputFile << currentKey << "," << std::fixed << std::setprecision(7) << average << std::endl;

                count = 0;
                sum = 0.0;
            }
        }

        inputFile.close();
        outputFile.close();
        std::cout << "Media calculada e salva em " << arquivoSaida << std::endl;
    }
    ```

    - Para uma melhor an√°lise dos dados e para facilitar para plotar os gr√°ficos, foi criada a fun√ß√£o `reorganizacaoArquivoResultados` para reorganizar os dados de forma com que podemos visualizar cada MinMax separadamente e suas varia√ß√µes. 

    ```cpp
    void reorganizacaoArquivoResultados(std::string arquivoEntrada, std::string arquivoSaida) {
        std::ifstream inputFile(arquivoEntrada);    
        std::string MinMax11, MinMax21, MinMax31;
        std::string MinMax12, MinMax22, MinMax32;
        std::string MinMax13, MinMax23, MinMax33;

        if (!inputFile) {
            std::cerr << "Erro ao abrir arquivo de entrada." << std::endl;
            return;
        }

        std::string line;
        while (std::getline(inputFile, line)) {
            std::istringstream ss(line);
            std::string token;
            std::vector<std::string> tokens;
            int ordem;
            
            while (std::getline(ss, token, ',')) {
                tokens.push_back(token);
            }

            int numeroColuna3 = std::stoi(tokens[2]);
            std::string coluna2 = tokens[1];
            if (numeroColuna3 == 1 && coluna2 == "Aleatorio") {
            MinMax11 += line + "\n";
            } else if (numeroColuna3 == 2 && coluna2 == "Aleatorio") {
                MinMax12 += line + "\n";
            } else if (numeroColuna3 == 3 && coluna2 == "Aleatorio") {
                MinMax13 += line + "\n";
            } else if (numeroColuna3 == 1 && coluna2 == "Crescente") {
                MinMax21 += line + "\n";
            } else if (numeroColuna3 == 2 && coluna2 == "Crescente") {
                MinMax22 += line + "\n";
            } else if (numeroColuna3 == 3 && coluna2 == "Crescente") {
                MinMax23 += line + "\n";
            } else if (numeroColuna3 == 1 && coluna2 == "Decrescente") {
                MinMax31 += line + "\n";
            } else if (numeroColuna3 == 2 && coluna2 == "Decrescente") {
                MinMax32 += line + "\n";
            } else if (numeroColuna3 == 3 && coluna2 == "Decrescente") {
                MinMax33 += line + "\n";
            }
        }

        inputFile.close();

        std::ofstream outputFile(arquivoSaida);
        if (!outputFile.is_open()) {
            std::cerr << "Erro ao abrir arquivo de sa√≠da." << std::endl;
            return;
        }

        outputFile <<  MinMax11 <<  MinMax21 <<  MinMax31 <<  MinMax12 <<  MinMax22 <<  MinMax32 <<  MinMax13 <<  MinMax23 <<  MinMax33;

        outputFile.close();
        std::cout << "Reorganizacao dos dados para outra analise salva em " << arquivoSaida << std::endl;
    }
    ```

    - Depois √© calculada a m√©dia novamente, por√©m usando como entrada esse novo arquivo reorganizado. 

## üìà Gera√ß√£o de Gr√°ficos Gnuplot
A gera√ß√£o de gr√°ficos √© uma etapa crucial para visualizar e interpretar os resultados obtidos a partir da execu√ß√£o dos algoritmos. Isso √© feito utilizando uma ferramenta de plotagem, como o Gnuplot. O processo envolve as seguintes etapas:

### üìä Primeiro tipo plotagem 
1. **Arquivo resultadosMedias.csv:** O arquivo `resultadosMedias.csv` √© um arquivo CSV (Comma-Separated Values) que armazena os resultados da execu√ß√£o dos algoritmos em diferentes cen√°rios. Cada linha do arquivo cont√©m dados relacionados a uma execu√ß√£o espec√≠fica do algoritmo, e os dados s√£o organizados da seguinte forma:

    - *Tamanho do vetor (`n`):* Representa o tamanho do vetor utilizado na execu√ß√£o do algoritmo.
    
    - *Tipo de organiza√ß√£o do vetor:* Indica se o vetor foi organizado de forma aleat√≥ria, crescente ou decrescente.

    - *N√∫mero do algoritmo:* Identifica qual algoritmo foi executado. No exemplo fornecido, os valores poss√≠veis s√£o 1, 2 e 3, correspondendo aos algoritmos `MaxMin1`, `MaxMin2` e `MaxMin3`, respectivamente.
    
    - *Tempo de execu√ß√£o m√©dio:* Representa o tempo m√©dio de execu√ß√£o do algoritmo, medido em segundos.

2. **C√≥digo para Gera√ß√£o de Gr√°ficos (plotGraficoMedias.gp):** Para uma an√°lise visual dos resultados obtidos a partir da execu√ß√£o dos algoritmos, s√£o gerados gr√°ficos que representam o tempo de execu√ß√£o em diferentes cen√°rios. Esses gr√°ficos s√£o gerados a partir dos dados contidos no arquivo `resultadosMedias.csv`, onde cada linha representa uma execu√ß√£o espec√≠fica dos algoritmos.

    - *Defini√ß√£o do Terminal de Sa√≠da:* O c√≥digo define o formato de sa√≠da dos gr√°ficos como PNG.

    - *Determina√ß√£o do N√∫mero Total de Linhas no Arquivo:* Utiliza o comando do sistema `wc` para contar o n√∫mero total de linhas no arquivo `resultadosMedias.csv`. Isso permite determinar quantos gr√°ficos ser√£o gerados.
        ```gnuplot
        set terminal png

        # N√∫mero de linhas a serem plotadas em cada gr√°fico
        linhas_por_grafico = 3

        # N√∫mero total de linhas no arquivo
        total_linhas = system('wc -l < "../datasets/resultadosMedias.csv"')
        ```
    - *Defini√ß√£o da Fun√ß√£o para Plotar os Dados:* A fun√ß√£o `plotarDados` √© respons√°vel por gerar um script Gnuplot para plotar os dados de tempo de execu√ß√£o em um gr√°fico. Ela recebe v√°rios par√¢metros que s√£o essenciais para a cria√ß√£o do script Gnuplot:
        - `linha_inicial`: Representa a linha inicial dos dados a serem plotados.
        - `linha_final`: Representa a linha final dos dados a serem plotados.
        - `indice`: √çndice do gr√°fico, utilizado para identificar cada gr√°fico gerado.
        - `n`: Tamanho do vetor utilizado na execu√ß√£o do algoritmo.
        - `tipo`: Tipo de organiza√ß√£o do vetor (aleat√≥rio, crescente, decrescente).
        ```gnuplot
            # Define a fun√ß√£o para plotar os dados 
            plotarDados(linha_inicial, linha_final, indice, n, tipo) = sprintf("set terminal png\nset output '../images/plots/%s/graficoMedia%s.png'\nset datafile separator \",\"\nset title \"Grafico vetor de %s posi√ß√µes, organizado de forma %s\"\nset xlabel \" \"\nset ylabel \"Tempo de Execu√ß√£o\"\nset xtics (\"MinMax1\" 1, \"MinMax2\" 2, \"MinMax3\" 3)\nset key font \"Arial, 1\"\nplot \"../datasets/resultadosMedias.csv\" every ::%d::%d using 3:4 with lines title \"Tempo de Execu√ß√£o - Linhas\", '' every ::%d::%d using 3:4 with points title \"Tempo de Execu√ß√£o - Pontos\"", tipo, n, n, tipo, linha_inicial, linha_final, linha_inicial, linha_final)

        ```

        A fun√ß√£o ent√£o utiliza esses par√¢metros para formatar um script Gnuplot que plota os dados correspondentes ao intervalo de linhas especificado. Ela define v√°rios par√¢metros do gr√°fico, como t√≠tulo, r√≥tulos dos eixos e estilo das linhas.
        - Exemplo de Script Gnuplot Gerado pela fun√ß√£o `plotarDados`:
            - O gr√°fico √© salvo como `graficoMedia1.png` na pasta `../images/plots/Aleatorio/`.
            - Os dados s√£o lidos do arquivo `resultadosMedias.csv` e apenas as linhas de 0 a 2 s√£o consideradas.
            - O gr√°fico tem um t√≠tulo descritivo, r√≥tulos nos eixos x e y, e um r√≥tulo adicional explicando o contexto dos dados.
            - As linhas de dados s√£o plotadas com estilo de linha cont√≠nua.
            ```gnuplot
            set terminal png
            set terminal png
            set output '../images/plots/Aleatorio/graficoMedia1000.png'
            set datafile separator ","
            set title "Grafico vetor de 1000 posi√ß√µes, organizado de forma Aleatorio"
            set xlabel " "
            set ylabel "Tempo de Execu√ß√£o"
            set xtics ("MinMax1" 1, "MinMax2" 2, "MinMax3" 3)
            set key font "Arial, 1"
            plot "../datasets/resultadosMedias.csv" every ::0::2 using 3:4 with lines title "Tempo de Execu√ß√£o - Linhas", '' every ::0::2 using 3:4 with points title "Tempo de Execu√ß√£o - Pontos"
            ``` 

    - *Loop para Gera√ß√£o de Scripts e Gr√°ficos:* Um loop percorre o arquivo `resultadosMedias.csv` em incrementos de linhas. Para cada conjunto de dados, um script Gnuplot √© gerado chamando a fun√ß√£o `plotarDados`.

        1. *Defini√ß√£o do Intervalo de Linhas:* este loop percorre o intervalo de valores de `linha`, iniciando em 0 e indo at√© `total_linhas-linhas_por_grafico`, avan√ßando de `linhas_por_grafico` em `linhas_por_grafico`. Cada itera√ß√£o do loop processar√° um conjunto de linhas de dados do arquivo `resultados.csv`.
            ```gnuplot
                do for [linha = 0:total_linhas-linhas_por_grafico:linhas_por_grafico] {
            ``` 

        2. *Obten√ß√£o dos Dados:* Para cada itera√ß√£o do loop, √© determinada a linha inicial `linha_dados` a partir do valor de `linha`. Em seguida, s√£o obtidos os dados relevantes para a gera√ß√£o do gr√°fico a partir do arquivo `resultados.csv`. O tamanho do vetor `n` e o tipo de organiza√ß√£o do vetor `tipo` s√£o extra√≠dos da linha especificada.
            ```gnuplot
                linha_dados = linha + 1  # A linha dos dados na planilha come√ßa do 1, n√£o do 0
                n = system(sprintf("awk -F',' 'NR==%d{print $1}' ../datasets/resultadosMedias.csv", linha_dados))
                tipo = system(sprintf("awk -F',' 'NR==%d{print $2}' ../datasets/resultadosMedias.csv", linha_dados))
            ``` 
        
        3. *C√°lculo dos √çndices e do Nome do Script:*  S√£o calculadas a linha inicial `linha_inicial` e a linha final `linha_final` do conjunto de dados a ser plotado. O √≠ndice do gr√°fico `indice` √© calculado com base no n√∫mero de linhas por gr√°fico. Al√©m disso, √© gerado um nome √∫nico para o script Gnuplot correspondente ao gr√°fico atual.
            ```gnuplot
                linha_inicial = linha
                linha_final = (linha -1) + linhas_por_grafico
                indice = linha / linhas_por_grafico + 1
                script_nome = sprintf("script_%d.gp", indice)
            ``` 

        4. *Ger√ß√£o do Script Gnuplot:* A fun√ß√£o `plotarDados` √© chamada para gerar o script Gnuplot espec√≠fico para o conjunto de dados atual. Esta fun√ß√£o cria um script formatado com base nos par√¢metros fornecidos.
            ```gnuplot
                script = plotarDados(linha_inicial, linha_final, indice, n, tipo)
            ``` 

        5. *Impress√£o do Script em um Arquivo:* O script Gnuplot gerado √© impresso em um arquivo com o nome correspondente ao `script_nome`.
            ```gnuplot
                set print script_nome
                print script
                set print
            ``` 

        6. *Execu√ß√£o do Script Gnuplot:* O script Gnuplot √© executado pelo Gnuplot, o que resulta na gera√ß√£o do gr√°fico correspondente ao conjunto de dados processado.
            ```gnuplot
                system(sprintf("gnuplot %s", script_nome))
            ``` 

    - *Limpeza dos Scripts Gerados:* Ap√≥s a gera√ß√£o dos gr√°ficos, os scripts Gnuplot gerados s√£o removidos para manter a organiza√ß√£o do ambiente de trabalho. 
        ```gnuplot
            # Apaga os scripts gerados ap√≥s a execu√ß√£o
            system("rm script_*.gp")    
        ``` 


### üìä Segundo tipo plotagem 
1. **Arquivo resultadosMinMaxMedias.csv:** Assim como o anterior, os dados s√£o buscados no arquivo `resultadosMinMaxMedias.csv`, e tem a mesma organiza√ß√£o dos dados nas colunas (tamanho do vetor, tipo de organiza√ß√£o do vetor, n√∫mero do algoritmo, tempo de execu√ß√£o m√©dio). O que difere ele do arquivo `resultadosMedias.csv` √© a como √© organizado em linhas. Neste √© colocado em ordem dos Algoritmos (`MaxMin1`, `MaxMin2` e `MaxMin3`), j√° no outro foi colocado como predominancia de organiza√ß√£o os tamanhos dos vetores (1000, 10000, 100000, 500000). 

2. **C√≥digo para Gera√ß√£o de Gr√°ficos (plotGraficoMinMax.gp):** Aqui tamb√©m segue o mesmo padr√£o do outro script, tendo poucas adapta√ß√µes. Segue as diferen√ßas: 

    - *Determina√ß√£o do N√∫mero Total de Linhas no Arquivo:* S√£o pegas a 4 linhas do arquivo `resultadosMinMaxMedias.csv` para plotar cada gr√°fico. S√£o 4 porque s√£o os 4 tipos de tamanhos de vetores diferentes. 

    - *Defini√ß√£o da Fun√ß√£o para Plotar os Dados:* A fun√ß√£o `plotarDados` tamb√©m permanece aq, por√©m com algumas mudan√ßas. No lugar do paretro `n`, foi colocadoo par√¢metro `algoritmo`, que ir√° identificar qual `MinMax` est√° sendo usado.  

        - Exemplo de Script Gnuplot Gerado pela fun√ß√£o `plotarDados` do script `plotGraficoMinMax.gp`:
            - O gr√°fico √© salvo como `graficoMinMax1.png` na pasta `../images/plots/Aleatorio/`.
            - Os dados s√£o lidos do arquivo `resultadosMinMaxMedias.csv` e apenas as linhas de 0 a 3 s√£o consideradas.
            - O gr√°fico tem um t√≠tulo descritivo, r√≥tulos nos eixos x e y, e um r√≥tulo adicional explicando o contexto dos dados.
            - As linhas de dados s√£o plotadas com estilo de linha cont√≠nua.
            ```gnuplot
            set terminal png size 900,400
            set output '../images/plots/Aleatorio/graficoMinMax1.png'
            set datafile separator ","
            set title "Grafico MinMax1, organizado de forma Aleatorio"
            set xlabel " "
            set ylabel "Tempo de Execu√ß√£o"
            set key font "Arial, 1"
            plot "../datasets/resultadosMinMaxMedias.csv" every ::0::3 using 1:4 with lines title "Tempo de Execu√ß√£o - Linhas", '' every ::0::3 using 1:4 with points title "Tempo de Execu√ß√£o - Pontos"

            ``` 

    - *O Script:* Segue abaixo o script completo `plotarGraficoMinMax.gp`: 
    ```gnuplot
        set terminal png

        # N√∫mero de linhas a serem plotadas em cada gr√°fico
        linhas_por_grafico = 4

        # N√∫mero total de linhas no arquivo
        total_linhas = system('wc -l < "../datasets/resultadosMinMaxMedias.csv"')

        # Define a fun√ß√£o para plotar os dados de acordo com os par√¢metros passados
        plotarDados(linha_inicial, linha_final, indice, algoritmo, tipo) = sprintf("set terminal png size 900,400\nset output '../images/plots/%s/graficoMinMax%s.png'\nset datafile separator \",\"\nset title \"Grafico MinMax%s, organizado de forma %s\"\nset xlabel \" \"\nset ylabel \"Tempo de Execu√ß√£o\"\nset key font \"Arial, 1\"\nplot \"../datasets/resultadosMinMaxMedias.csv\" every ::%d::%d using 1:4 with lines title \"Tempo de Execu√ß√£o - Linhas\", '' every ::%d::%d using 1:4 with points title \"Tempo de Execu√ß√£o - Pontos\"", tipo, algoritmo, algoritmo, tipo, linha_inicial, linha_final, linha_inicial, linha_final)

        # Gera um script para cada conjunto de linhas
        do for [linha = 0:total_linhas-linhas_por_grafico:linhas_por_grafico] {
            linha_dados = linha + 1  # A linha dos dados na planilha come√ßa do 1, n√£o do 0
            algoritmo = system(sprintf("awk -F',' 'NR==%d{print $3}' ../datasets/resultadosMinMaxMedias.csv", linha_dados))
            tipo = system(sprintf("awk -F',' 'NR==%d{print $2}' ../datasets/resultadosMinMaxMedias.csv", linha_dados))
            
            linha_inicial = linha
            linha_final = (linha -1) + linhas_por_grafico
            indice = linha / linhas_por_grafico + 1
            script_nome = sprintf("script_%d.gp", indice)
            script = plotarDados(linha_inicial, linha_final, indice, algoritmo, tipo)
            set print script_nome
            print script
            set print
            # Executa o script gerado
            system(sprintf("gnuplot %s", script_nome))
        }

        # Apaga os scripts gerados ap√≥s a execu√ß√£o
        system("rm script_*.gp")
    ```

## üìÇ Estrutura de Diret√≥rios

O projeto √© organizado da seguinte forma:

```<figure align="center">
  <img src="./images/imgs_readme/notacaoOmega.jpeg" alt="Gr√°fico Exemplo" width="500" >
  <figcaption>Fonte: Autor</figcaption>
</figure>
‚îÇ   ‚îÇ   |   ‚îî‚îÄ‚îÄ app
‚îú‚îÄ‚îÄ datasets
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ resultados.csv
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ resultadosMedias.csv
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ resultadosMinMax.csv
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ resultadosMinMaxMedias.csv
‚îú‚îÄ‚îÄ images
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ imgs_readme
‚îÇ   ‚îÇ   |   ‚îú‚îÄ‚îÄ minMax.o
‚îÇ   ‚îÇ   |   ‚îî‚îÄ‚îÄ main.o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ plots
‚îÇ   ‚îÇ   |   ‚îú‚îÄ‚îÄ Aleatorio
‚îÇ   ‚îÇ   |   |   ‚îú‚îÄ‚îÄ graficoMedia1000.png
‚îÇ   ‚îÇ   |   |   ‚îú‚îÄ‚îÄ graficoMedia10000.png
‚îÇ   ‚îÇ   |   |   ‚îú‚îÄ‚îÄ graficoMedia100000.png
‚îÇ   ‚îÇ   |   |   ‚îú‚îÄ‚îÄ graficoMedia500000.png
‚îÇ   ‚îÇ   |   |   ‚îú‚îÄ‚îÄ graficoMinMax1.png
‚îÇ   ‚îÇ   |   |   ‚îú‚îÄ‚îÄ graficoMinMax3.png
‚îÇ   ‚îÇ   |   |   ‚îî‚îÄ‚îÄ graficoMinMax3.png
‚îÇ   ‚îÇ   |   ‚îú‚îÄ‚îÄ Crescente
‚îÇ   ‚îÇ   |   |   ‚îú‚îÄ‚îÄ graficoMedia1000.png
‚îÇ   ‚îÇ   |   |   ‚îú‚îÄ‚îÄ graficoMedia10000.png
‚îÇ   ‚îÇ   |   |   ‚îú‚îÄ‚îÄ graficoMedia100000.png
‚îÇ   ‚îÇ   |   |   ‚îú‚îÄ‚îÄ graficoMedia500000.png
‚îÇ   ‚îÇ   |   |   ‚îú‚îÄ‚îÄ graficoMinMax1.png
‚îÇ   ‚îÇ   |   |   ‚îú‚îÄ‚îÄ graficoMinMax3.png
‚îÇ   ‚îÇ   |   |   ‚îî‚îÄ‚îÄ graficoMinMax3.png
‚îÇ   ‚îÇ   |   ‚îî‚îÄ‚îÄ Decrescente
‚îÇ   ‚îÇ   |   |   ‚îú‚îÄ‚îÄ graficoMedia1000.png
‚îÇ   ‚îÇ   |   |   ‚îú‚îÄ‚îÄ graficoMedia10000.png
‚îÇ   ‚îÇ   |   |   ‚îú‚îÄ‚îÄ graficoMedia100000.png
‚îÇ   ‚îÇ   |   |   ‚îú‚îÄ‚îÄ graficoMedia500000.png
‚îÇ   ‚îÇ   |   |   ‚îú‚îÄ‚îÄ graficoMinMax1.png
‚îÇ   ‚îÇ   |   |   ‚îú‚îÄ‚îÄ graficoMinMax3.png
‚îÇ   ‚îÇ   |   |   ‚îî‚îÄ‚îÄ graficoMinMax3.png
‚îú‚îÄ‚îÄ src
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.cpp
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ minMax.cpp
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ minMax.hpp
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ plotGraficoMedias.gp
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ plotGraficoMinMax.gp
‚îú‚îÄ‚îÄ makefile
‚îî‚îÄ‚îÄ README.md
```
Esta estrutura de diret√≥rios facilita a organiza√ß√£o do projeto e a localiza√ß√£o dos arquivos necess√°rios para compilar o c√≥digo-fonte, executar o programa e visualizar os resultados.

## üìö Como Usar

1. Clone este reposit√≥rio:

    ```bash
    git clone https://github.com/dudatsouza/minMax.git

2. Antes de compilar o programa, √© recomendado executar o comando `make clean` para garantir que todos os arquivos compilados anteriores sejam removidos:

    ```bash
    make clean
    ```

3. Em seguida, compile o programa usando o Makefile:

    ```bash
    make
    ```

4. Execute o programa, fornecendo o nome do arquivo de entrada:

    ```bash
    make run 
    ```

5. Os gr√°ficos gerados ser√£o salvos na pasta `plots`. Voc√™ pode visualiz√°-los para analisar o desempenho dos algoritmos para diferentes tamanhos de vetores e organiza√ß√µes.

## üìã Exemplos

### üìÑ Arquivos de entradas:
Os arquivos de entradas vc pode est√° pegando de exemplos os que est√£o dispon√≠veis na pasta `/datasets`. L√° voc√™ vai encontrar os arquivos: 
- `resultados.csv`
- `resultadosMedias.csv`
- `resultadosMinMax.csv`
- `resultadosMinMaxMedias.csv`


### üìÑ Exemplo de Sa√≠da de um dos Gr√°ficos:
1. **Primeiro tipo de plotagem:** 
A partir do script `plotGaficoMedias.gp` s√£o plotados 12 gr√°ficos, cada um pegando a diferen√ßa entre o tempo de execu√ß√£o dos tr√™s MaxMin. Aqui est√° um exemplo de um dos gr√°ficos gerados a partir dos dados do arquivo `resultadosMedias.csv`: 
<p align="center">
    <figure align="center">
    <img src="./images/imgs_readme/graficoExemploMedias.png" alt="Gr√°fico Exemplo" width="500" >
    <figcaption>Fonte: Autor</figcaption>
    </figure>
</p>

**OBSERVA√á√ÉO:** Foram plotados um total de 12 gr√°ficos, representando diferentes tamanhos de vetores e organiza√ß√µes, mostrando a varia√ß√£o do tempo de execu√ß√£o de acordo com o MinMax usado.

2. **Segundo tipo de plotagem:** 
A partir do script `plotGaficoMinMax.gp` s√£o plotados 9 gr√°ficos, cada um pegando a diferen√ßa entre o tempo de execu√ß√£o de acordo com o tamanho do vetor. Aqui est√° um exemplo de um dos gr√°ficos gerados a partir dos dados do arquivo `resultadosMiinMaxMedias.csv`: 
<p align="center">
    <figure align="center">
    <img src="./images/imgs_readme/graficoExemploMinMax.png" alt="Gr√°fico Exemplo" width="500" >
    <figcaption>Fonte: Autor</figcaption>
    </figure>
</p>

**OBSERVA√á√ÉO:** Foram plotados um total de 9 gr√°ficos, representando diferentes organiza√ß√µes e MinMaxs usados, mostrando a varia√ß√£o do tempo de execu√ß√£o de acordo com o tamanho do vetor.

## üìà Resultados das An√°lises
Analisamos o desempenho de tr√™s diferentes implementa√ß√µes de algoritmos MinMax em uma s√©rie de cen√°rios de teste. Ao examinar os resultados, procuramos identificar padr√µes de desempenho, vantagens e limita√ß√µes de cada abordagem.

### 1Ô∏è‚É£ Algoritmo MaxMin1

- **Melhor Caso:** Ocorre quando o array est√° ordenado de forma crescente ou decrescente. Cada elemento √© comparado uma vez com o pr√≥ximo, resultando em \( n - 1 \) compara√ß√µes. Como o algoritmo precisa encontrar tanto o m√°ximo quanto o m√≠nimo, s√£o realizadas duas compara√ß√µes para cada elemento. Portanto, \( f(n) = 2(n - 1) \).
  
- **Pior Caso:** Ocorre quando o array est√° ordenado de forma que o maior elemento esteja no in√≠cio e o menor no final (ou vice-versa). Nesse caso, cada elemento √© comparado com ambos o m√°ximo e o m√≠nimo, resultando em \( 2(n - 1) \) compara√ß√µes. Portanto, \( f(n) = 2(n - 1) \).
  
- **Caso M√©dio:** O comportamento m√©dio √© semelhante ao pior caso, pois as compara√ß√µes s√£o feitas de maneira semelhante. Portanto, \( f(n) = 2(n - 1) \).

### 2Ô∏è‚É£ Algoritmo MaxMin2

- **Melhor Caso:** Ocorre quando o array est√° ordenado de forma crescente. Apenas o primeiro elemento √© comparado com o m√°ximo e o m√≠nimo, resultando em \( n - 1 \) compara√ß√µes. Portanto, \( f(n) = n - 1 \).
  
- **Pior Caso:** Ocorre quando o array est√° ordenado de forma decrescente. Cada elemento √© comparado com ambos o m√°ximo e o m√≠nimo, resultando em \( 2(n - 1) \) compara√ß√µes. Portanto, \( f(n) = 2(n - 1) \).
   
- **Caso M√©dio:** Considerando um conjunto de dados em que haver√° \( (n - 1) \) passagens no primeiro "if" e \( (n - 1) / 2 \) no "else", resultando em \( f(n) = (n - 1) + (n - 1) / 2 = (3n / 2) - (3 / 2) \).

### 3Ô∏è‚É£ Algoritmo MaxMin3

- **Melhor, Pior e Caso M√©dio:** Neste algoritmo, os elementos s√£o avaliados em pares, resultando em \( \frac{n}{2} \) compara√ß√µes. O maior elemento √© obtido pelo primeiro "if" com um custo de \( (n / 2) - 1 \) compara√ß√µes, enquanto o menor √© obtido pelo segundo "if" com um custo de \( (n / 2) - 1 \) compara√ß√µes. Portanto, o custo total √© \( f(n) = (n / 2) + (n - 2) / 2 + (n - 2) / 2 = (3n / 2) - 2 \).

Observe a imagem abaixo, onde mostra exatamente isso que acabamos de discutir: 
<p align="center">
    <figure align="center">
    <img src="./images/imgs_readme/casosMinmaxs.jpeg" alt="Gr√°fico Exemplo" width="500" >
    <figcaption>Fonte: Autor</figcaption>
    </figure>
</p>


### üìä Visualizando a teoria na pr√°tica
Aqui exploraremos os resultados pr√°ticos obtidos a partir da execu√ß√£o do programa, a fim de visualizar como os dados se relacionam com as an√°lises te√≥ricas dos algoritmos MinMax.

#### üìà Olhando os gr√°ficos plotados pelo script `plotGraficosMedias.gp`
Foi poss√≠vel ver nos gr√°ficos gerados pelo script `plotGraficoMedias.gp`o andamento e exatamente acontecendo o que foi explicado e analisado anteriormente.

Uma das coisas observadas foi que apesar da an√°lise te√≥rica indicar um custo de (3n / 2) - 2 para o algoritmo MinMax3 em todos os casos, ele parece apresentar um desempenho inferior em compara√ß√£o com os outros algoritmos, especialmente quando os dados s√£o aleat√≥rios.

**Exemplo de An√°lise:** Olhando para o seguinte gr√°fico de umas das execu√ß√µes podemos ver isso acontecendo: 
<p align="center">
    <figure align="center">
    <img src="./images/imgs_readme/graficoMedia500000.png" alt="Gr√°fico Exemplo" width="500" >
    <figcaption>Fonte: Autor</figcaption>
    </figure>
</p>

Usando dados aleat√≥rios: 
- *Algoritmo MaxMin1:* f(n) = 2(n - 1)
- *Algoritmo MaxMin2:* f(n) = 2(n - 1)
- *Algoritmo MaxMin3:* f(n) = (3n / 2) - 2


Observamos que, ao usar conjuntos de dados aleat√≥rios, os algoritmos MaxMin1 e MaxMin2 geralmente superam o algoritmo MaxMin3 em termos de tempo de execu√ß√£o. Isso √© surpreendente, considerando que o custo te√≥rico do algoritmo MinMax3 √© o menor que o dos outros algoritmos.

##### ü§î **Poss√≠veis Explica√ß√µes:**

1. **Padr√£o de Acesso √† Mem√≥ria:** √â poss√≠vel que o algoritmo MinMax3 tenha um padr√£o de acesso √† mem√≥ria menos favor√°vel, o que pode impactar negativamente seu desempenho em sistemas reais.

2. **Caracter√≠sticas dos Dados de Entrada:** Os dados aleat√≥rios podem n√£o ser ideais para o algoritmo MinMax3, especialmente se eles n√£o seguirem um padr√£o espec√≠fico que o algoritmo possa explorar para otimizar sua execu√ß√£o.

Embora a an√°lise te√≥rica forne√ßa uma estimativa do desempenho dos algoritmos, os resultados experimentais destacam a import√¢ncia de validar essas previs√µes na pr√°tica. As discrep√¢ncias observadas entre os resultados te√≥ricos e pr√°ticos podem oferecer perspectivas para investiga√ß√µes e otimiza√ß√µes dos algoritmos.

#### üìà Olhando os gr√°ficos plotados pelo script `plotGraficosMinMax.gp`
Agora, quando analisamos os gr√°ficos gerados pelo script `plotGraficosMinMax.gp`, vemos de uma outra maneira as aplica√ß√µes das an√°lises que n√≥s fizemos. L√° mostra individualmente o desencolcimento de cada algoritmo MinMax. Percebemos que todos crescem de forma linar como nas nossa conclus√µes te√≥ricas, mesmo que os gr√°ficos n√£o geram uma linha perfeita, at√© porque eles s√£o plotados pela m√©dias de v√°rias execu√ß√µes, no entanto temos que considerar tamb√©m as margens de erros e situa√ß√µes diferentes de cada execu√ß√£o. 

**Exemplo de An√°lise:** Olhando para o seguinte gr√°fico de umas das execu√ß√µes podemos ver isso acontecendo: 
<p align="center">
    <figure align="center">
    <img src="./images/imgs_readme/graficoMinMax3.png" alt="Gr√°fico Exemplo" width="500" >
    <figcaption>Fonte: Autor</figcaption>
    </figure>
</p>

##### ü§î **Poss√≠veis Explica√ß√µes:**

1. **Varia√ß√µes na Carga do Sistema:** Durante as diferentes execu√ß√µes do programa, pode haver varia√ß√µes na carga do sistema, como outros processos em execu√ß√£o no computador, que podem afetar o desempenho do programa. Essas varia√ß√µes podem contribuir para as diferen√ßas nos resultados observados, mesmo quando se calculam m√©dias.

2. **Efeito de Cache e Mem√≥ria:** Os resultados pr√°ticos podem ser afetados pelo comportamento de cache e pelo acesso √† mem√≥ria do sistema. Pequenas varia√ß√µes no acesso √† mem√≥ria, como a localidade dos dados ou a ocorr√™ncia de falhas de cache, podem causar diferen√ßas nos tempos de execu√ß√£o, mesmo para os mesmos conjuntos de dados.

Portanto, ao interpretar os gr√°ficos e analisar o desempenho dos algoritmos, √© essencial estar ciente desses fatores e considerar como eles podem influenciar a precis√£o das conclus√µes tiradas a partir dos resultados experimentais.

## üéâ Conclus√£o 
Neste trabalho, foi explorado os algoritmos de MinMax teoricamente e experimentalmente. Enquanto as an√°lises te√≥ricas forneceram previs√µes √∫teis, os resultados pr√°ticos destacaram diferen√ßas significativas. Observamos que o desempenho dos algoritmos foi influenciado por varia√ß√µes nos dados de entrada e outros fatores pr√°ticos. Essas descobertas destacam a import√¢ncia de uma abordagem integrada ao estudar algoritmos, combinando an√°lises te√≥ricas com experimentos pr√°ticos para uma compreens√£o mais completa de seu comportamento.

## üî® Ambiente de Compila√ß√£o

A seguir est√£o os detalhes do ambiente de compila√ß√£o onde o programa foi executado:

| Componente      | Detalhes                          |
|-----------------|-----------------------------------|
| Sistema Operacional | Ununtu 22.04.4 LTS  - 64 bits|
| Modelo do hardware| Dell Inc. Inspiron 3501|
| Processador     | Intel¬Æ Core‚Ñ¢ i3-1005G1 CPU @ 1.20GHz √ó 4|
| Mem√≥ria RAM     | 8 GB, 1 de 8 GB, DDR4, 2.666 MHz|
| Armazenamento   | 256 GB, M.2 2230, PCIe NVMe de 3¬™ gera√ß√£o x4, SSD|
| IDE             | Visual Studio Code|

Observa√ß√£o: Os detalhes acima s√£o baseados no ambiente de compila√ß√£o utilizado durante o desenvolvimento do programa e podem variar em diferentes sistemas.


## ‚õè Makefile

O Makefile √© um utilit√°rio que automatiza o processo de compila√ß√£o e execu√ß√£o de programas. Aqui est√£o os principais comandos do Makefile para este projeto:

| Comando      | Descri√ß√£o                               |
|--------------|-----------------------------------------|
| `make`       | Compila o programa.                     |
| `make run`   | Executa o programa com o arquivo de entrada fornecido. |
| `make clean` | Remove os arquivos compilados.          |


## üìß Contato

Para mais informa√ß√µes ou sugest√µes, sinta-se √† vontade para entrar em contato:

- ‚úâÔ∏è **E-mail**: [![Gmail Badge](https://img.shields.io/badge/-dudateixeirasouza@gmail.com-c14438?style=flat-square&logo=Gmail&logoColor=white&link=mailto:dudateixeirasouza@gmail.com)](mailto:dudateixeirasouza@gmail.com)
- üíº **LinkedIn**: [![Linkedin Badge](https://img.shields.io/badge/-LinkedIn-0e76a8?style=flat-square&logo=Linkedin&logoColor=white)](https://www.linkedin.com/in/maria-eduarda-teixeira-souza-2a2b3a254/)
- üì∏ **Instagram**: [![Instagram Badge](https://img.shields.io/badge/-Instagram-e4405f?style=flat-square&logo=Instagram&logoColor=white)](https://www.instagram.com/dudat_18/)

Ficarei feliz em receber feedbacks, contribui√ß√µes ou responder a quaisquer d√∫vidas que voc√™ possa ter sobre o programa. 

## üîñ Refer√™ncias
1. Jo√£o Arthur. **An√°lise Assint√≥tica**. Dispon√≠vel em: [https://joaoarthurbm.github.io/eda/posts/analise-assintotica/](https://joaoarthurbm.github.io/eda/posts/analise-assintotica/). Acesso em: 12 abr. 2024.

2. Pereira, F. **An√°lise de Algoritmos**. Dispon√≠vel em: [https://www.ime.usp.br/~pf/analise_de_algoritmos/](https://www.ime.usp.br/~pf/analise_de_algoritmos/). Acesso em: 12 abr. 2024.

3. XVI ENID. **PROLICEN: Engenharia de Software: an√°lise de complexidade assint√≥tica de algoritmos**. Dispon√≠vel em: [http://www.prac.ufpb.br/enex/XVENID/PROLICEN/CCAE/25.pdf](http://www.prac.ufpb.br/enex/XVENID/PROLICEN/CCAE/25.pdf). Acesso em: 12 abr. 2024.

4. Hokama. **CIC110 - Estrutura de Dados - An√°lise Assint√≥tica**. Dispon√≠vel em: [https://hokama.com.br/disciplinas/cic110_2019s2/02-analise-assintotica.pdf](https://hokama.com.br/disciplinas/cic110_2019s2/02-analise-assintotica.pdf). Acesso em: 12 abr. 2024.

5. Martins, A. **An√°lise de Complexidade de Algoritmos**. Dispon√≠vel em: [http://www.deinf.ufma.br/~acmo/grad/ED_complexidade_2005.pdf](http://www.deinf.ufma.br/~acmo/grad/ED_complexidade_2005.pdf). Acesso em: 12 abr. 2024.

6. Reinaldo. **An√°lise de Algoritmos (Parte 3)**. Dispon√≠vel em: [http://www.decom.ufop.br/reinaldo/site_media/uploads/2014-01-bcc202/aulas/aula_06_-_analise_de_algoritmos_(parte_3)_(v1).pdf](http://www.decom.ufop.br/reinaldo/site_media/uploads/2014-01-bcc202/aulas/aula_06_-_analise_de_algoritmos_(parte_3)_(v1).pdf). Acesso em: 12 abr. 2024.

7. CEFET-MG. **Aula 1 - An√°lise de Algoritmos**. Dispon√≠vel em: [https://ava.cefetmg.br/pluginfile.php/250215/mod_resource/content/8/Aula1.pdf](https://ava.cefetmg.br/pluginfile.php/250215/mod_resource/content/8/Aula1.pdf). Acesso em: 12 abr. 2024.
